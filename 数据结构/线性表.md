 ## 一、基本功夫
 #### 1.1 数据结构和算法的基本概念
 > **1. 什么是数据结构？**
 >> 指互相之间存在的一种或者多种特定关系的数据元素的集合。包括逻辑结构，存储结构和对数据的运算。
 >
 >> 数据的逻辑结构：对数据之间关系的描述。 主要有两大类：线性结构，非线性结构
 >> 数据的物理结构：又叫**存储结构**，常用的有：<font color="red">顺序存储方法，链式存储方法，索引存储方法，散列存储方法</font>四种。
 >
 > **2. 什么是线性结构?**
 >> 是一个数据元素的有序集合，有以下四个特征：
 &emsp;1）集合中必存在唯一的一个 “第一个元素”；
 &emsp;2）集合中必存在唯一的一个 “最后一个元素”；
 &emsp;3）除最后一个元素外，其他元素均有唯一的 “后继”；
 &emsp;4）除第一个元素外，其他元素均有唯一的 “前驱”；
 >
 > **3. 什么是非线性结构？**
 >> 非线性结构的结点存在一对多的关系，又可以细分成树形结构和图形结构。
 >
 > **4. 常见的数据结构和常用的算法？**
 >> 数据结构：栈，队列，数组，链表，树，图，堆，散列表
 >> 常用算法： 检索，插入，删除，更新，排序
 >
 > **5.算法的基本概念？**
 >> 算法的特性：有穷性，确定性，输入，输出，可行性
 >> 算法的设计目标：正确性，可读性，健壮性，高效率和低存储量需求。


 ### 二、排序篇
 #### 2.1 插入类排序
 - **直接插入排序**
```python
 def InsertSort(R:list):
    n = len(R)
    for i in range(n):
        temp = R[i]   # 将待插入关键字暂存于temp中
        j = i -1
        while j>=0 and temp<R[j]:
            R[j+1] = R[j]
            j -= 1
        R[j+1] = temp
    return R

A = input("Enter a array:")
arrayR = [int(n) for n in A.split()]
print("arrayR is:",arrayR)
InsertSort(arrayR)
```

 - **折半插入排序**
 ```python
 def BinaryInsertSort(arr):
    n = len(arr)
    for i in range(n):
        temp = arr[i]
        low = 0
        high = i-1
        # 开始折半查找
        while low <= high:
            m = (low + high) // 2
            if temp>arr[m]:
                low = m+1
            else:
                high = m-1
        for j in range(i,high+1,-1):
            arr[j] = arr[j-1]
        arr[low]=temp
    return arr

A = input("Enter a array:")
arrayR = [int(n) for n in A.split()]
print("arrayR:",arrayR)
arr = BinaryInsertSort(arrayR)
print("arr:",arr)
 ```

  - **希尔插入排序**
 ```python
def shellSort(arr): 
    n = len(arr)
    gap = int(n/2)
    while gap > 0: 
        for i in range(gap,n): 
            temp = arr[i] 
            j = i 
            while  j >= gap and arr[j-gap] >temp: 
                arr[j] = arr[j-gap] 
                j -= gap 
            arr[j] = temp 
        gap = int(gap/2)
    # return arr
A = input("Enter a array:")
arrayR = [int(n) for n in A.split()]
print("arrayR:",arrayR)
shellSort(arrayR)
print("arrayR:",arrayR)
 ```

#### 2.2 交换类排序
- **冒泡排序**
```python
def BubbleSort(arr):
    n = len(arr)
    for i in range(n-1):
        exchange = 0
        for j in range(n-i-1):
            if arr[j]>arr[j+1]:
                arr[j+1],arr[j]=arr[j],arr[j+1]
                exchange = 1  # 如果发生了交换，则flag为1，没有发生交换即为0
        print("After sort:",arr)
        if not exchange:
            return
    
A = input("Enter a array:")
arrayR = [int(n) for n in A.split()]
print("arrayR:",arrayR)
BubbleSort(arrayR)
```

- **快速排序**
```python
def partition(arr,low,high):
#     partition函数：取出第一个数temp，让小于temp的数都放在temp左边，大于temp数放在temp右边
    temp = arr[low]
    while low<high:
        while low<high and arr[high]>=temp:
            high -= 1
        arr[low] = arr[high]
        while low<high and arr[low]<=temp:
            low += 1
        arr[high] = arr[low]
    arr[low] = temp
    return low         

def QuickSort(arr,low,high):
    if low<high:
        mid = partition(arr,low,high)
        QuickSort(arr,low,mid-1)
        QuickSort(arr,mid+1,high)

A = input("Enter a array:")
arrayR = [int(n) for n in A.split()]
print("arrayR:",arrayR)
QuickSort(arrayR,0,len(arrayR)-1)
print(arrayR)
```

#### 2.3 选择类排序
- **简单选择排序**
```python
def SelectSort(arr):
    n = len(arr)
    new_arr = []
    for i in range(n):
        min_val = min(arr)
        new_arr.append(min_val)
        arr.remove(min_val)
    return new_arr

A = input("Enter a array:")
arrayR = [int(n) for n in A.split()]
print("arrayR:",arrayR)
SelectSort(arrayR)
```

- **堆排序**

#### 2.4 二路归并排序

#### 2.5 基数排序

#### 2.6 外部排序
- **置换选择排序**

- **最佳归并树**

- **败者树**

#### 2.7 排序篇总结

